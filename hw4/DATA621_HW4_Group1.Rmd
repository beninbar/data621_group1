---
title: 'Homework #4:  Multiple linear regression and Binary logistic regression'
subtitle: 'Critical Thinking Group 1'
author: 'Ben Inbar, Cliff Lee, Daria Dubovskaia, David Simbandumwe, Jeff Parks'
output:
  html_document:
    toc: yes
    toc_float: yes
    theme: united
  pdf_document:
    toc: yes
editor_options:
  chunk_output_type: console
  markdown: 
    wrap: sentence
---

```{r setup, include=FALSE}
# chunks
knitr::opts_chunk$set(echo=FALSE, eval=TRUE, include=TRUE, 
message=FALSE, warning=FALSE, fig.height=5)

# libraries
library(yardstick)

library(mice)
library(readr)
library(skimr)
library(ggplot2)
library(tidyverse)
library(reshape2)
library(MASS)
library(forecast)
library(kableExtra)
library(ggpubr)
library(fastDummies)

## To load the below libraries you might have to do the following in the console first:
####  install.packages("devtools")
####  devtools::install_github("haleyjeppson/ggmosaic")
####  devtools::install_github("thomasp85/patchwork")

library(ggmosaic)
library(patchwork)

library(caTools)
library(corrplot)
library(Hmisc)
library(glmnet)
library(vip)
library(caret)

# ggplot
theme_set(theme_bw())
```

```{r common functions}

#' glmnet_cv_aicc
#'
#' @param fit
#' @param lambda
#'
#' @return
#' @export
#'
#' @examples
glmnet_cv_aicc <- function(fit, lambda = 'lambda.1se'){
  whlm <- which(fit$lambda == fit[[lambda]])
  with(fit$glmnet.fit,
       {
         tLL <- nulldev - nulldev * (1 - dev.ratio)[whlm]
         k <- df[whlm]
         n <- nobs
         return(list('AICc' = - tLL + 2 * k + 2 * k * (k + 1) / (n - k - 1),
                     'BIC' = log(n) * k - tLL))
       })
}


#' coeff2dt
#'
#' @param fitobject 
#' @param s 
#'
#' @return
#' @export
#'
#' @examples
coeff2dt <- function(fitobject, s) {
  coeffs <- coef(fitobject, s) 
  coeffs.dt <- data.frame(name = coeffs@Dimnames[[1]][coeffs@i + 1], coefficient = coeffs@x) 

  # reorder the variables in term of coefficients
  return(coeffs.dt[order(coeffs.dt$coefficient, decreasing = T),])
}

```

```{r data}
# read train and evaluation datasets
train_df <- read.csv("https://raw.githubusercontent.com/cliftonleesps/data621_group1/main/hw4/insurance_training_data.csv")
eval_df <- read.csv("https://raw.githubusercontent.com/cliftonleesps/data621_group1/main/hw4/insurance-evaluation-data.csv")
```

## Overview

In this homework assignment, we will explore, analyze and model a data set containing approximately 8000 records representing a customer at an auto insurance company.
We will build multiple linear regression models on the continuous variable `TARGET_AMT` and binary logistic regression model on the boolean variable `TARGET_FLAG` to predict the probability that a person will crash their car, and to predict the associated costs.

We are going to build several models using different techniques and variable selection.
In order to best assess our predictive models, we will create a validation set within our training data along an 80/20 training/testing proportion, before applying the finalized models to a separate evaluation dataset that does not contain the target.

## 1. Data Exploration

The insurance training dataset contains 8161 observations of 26 variables, each record represents a customer at an auto insurance company.
The evaluation dataset contains 2141 observations of 26 variables.
These include demographic measures such as age and gender, socioeconomic measures such as education and household income, and vehicle-specific metrics such as car model, age and assessed value.

<img src="https://raw.githubusercontent.com/cliftonleesps/data621_group1/main/hw4/hw4_variables.png" width="1200" style="display: block; margin-left: auto; margin-right: auto; width: 100%;"/>

Each record also has two response variables.
The first response variable, `TARGET_FLAG`, is a boolean where "1" means that the person was in a car crash.
The second response variable, `TARGET_AMT` is a numeric indicating the (positive) cost if a car crash occurred; this value is zero if the person did not crash their car.

We can explore a sample of the training data here, and make some initial observations:

-   Some of the variables are character though they should be numeric and vice-versa.
-   Some currency variables are strings with '\$' symbols instead of numerics.
-   Some character variables include a prefix `z_` that could be removed for readability.

```{r summary1}
DT::datatable(
      train_df[1:500,],
      extensions = c('Scroller'),
      options = list(scrollY = 350,
                     scrollX = 500,
                     deferRender = TRUE,
                     scroller = TRUE,
                     dom = 'lBfrtip',
                     fixedColumns = TRUE, 
                     searching = FALSE), 
      rownames = FALSE) 
```

### 1.1 Summary Statistics

```{r prep}
# Drop INDEX
train_df <- train_df %>% dplyr::select(-INDEX)

## Remove z_ from character class values
z_vars <- c("MSTATUS","SEX","JOB","CAR_TYPE","URBANICITY","EDUCATION")
for (v in z_vars) {
  train_df <- train_df %>% mutate(!!v := str_replace(get(v),"z_",""))
}

# Update RED_CAR, replace [no,yes] values with [No, Yes] values
train_df <- train_df %>% mutate( RED_CAR = ifelse(RED_CAR == "no","No","Yes"))

# Instead of level "" will be "Unknown"
train_df$JOB[train_df$JOB==""] <- "Unknown"

# Convert currency columns from character class to integer
dollar_vars <- c("INCOME","HOME_VAL","BLUEBOOK","OLDCLAIM")
for (v in dollar_vars) {
  train_df <- train_df %>% mutate(!!v := str_replace(get(v),"[\\$,]",""))
}

currency_vars <- c("INCOME","HOME_VAL","BLUEBOOK","OLDCLAIM")

for (v in currency_vars) {
  train_df <- train_df %>% mutate(!!v := parse_number(get(v)))
}
```

The table below provides valuable descriptive statistics about the training data:

```{r summary}
skim_without_charts(train_df)
```

/

Based on this summary table and exploration of the data, we can make the following observations:

-   14 variables are categorical, 12 are numeric.
-   There is no missing data for character variables.
-   Numeric variables with missing values include `YOJ` (6%), `INCOME` (5%), `HOME_VAL` (6%), `CAR_AGE` (6%), and `AGE` (1%).
-   Most of the numeric variables have a minimum of zero.
-   One variable, `CAR_AGE` has a negative value of -3, which doesn't make intuitive sense.

### 1.2 Distributions

Before building a model, we need to make sure that we have both classes equally represented in our `TARGET_FLAG` variable.
Class `1` takes 27% and class `0` takes 63% of the target variable.
As a result, we have unbalanced class distribution for our target variable that we have to deal with, we have to take some additional steps (bootstrapping, etc) before using logistic regression.

```{r balance}
prop.table(table(train_df$TARGET_FLAG)) %>% 
  kable(label = "Distribution of Target Flag", 
        caption = "Distribution of Target Flag", 
        col.names = c("Value", "%"), 
        digits = 2) %>% 
    kable_styling(full_width = F) 
```

Many of these distributions seem highly skewed and non-normal.
As part of our data preparation we'll use power transformations to find whether transforming variables to more normal distributions improves our models' efficacy.

```{r, cache=TRUE}
dist_df <- train_df %>% dplyr::select(where(is.numeric)) %>%
  pivot_longer(!c(TARGET_FLAG,TARGET_AMT), 
               names_to = 'variable', 
               values_to = 'value') %>% 
  drop_na()

dist_df %>% ggplot(aes(x=value, group=TARGET_FLAG, fill=TARGET_FLAG)) +
  geom_density(color='#023020') + 
  facet_wrap(~variable, scales = 'free',  ncol = 4) + 
  theme_bw()
```

### 1.3 Box Plots

Commentary

```{r boxplot, cache=TRUE}
dist_df %>% ggplot(aes(x=value, group=TARGET_FLAG, fill=TARGET_FLAG)) + 
  geom_boxplot(color='#023020') + 
  facet_wrap(~variable, scales = 'free',  ncol = 4) + 
  theme_bw()
```

### 1.4 Scatter Plot

Interestingly, none of our predictors appear to have strong linear relationships to our `TARGET_AMT` response variable, which is a primary assumption of linear regression.
This suggests that alternative methods might be more successful in modeling the relationships.

```{r scatterplot, cache=TRUE}
dist_df %>% drop_na() %>% ggplot(aes(x=value, y=TARGET_AMT)) + 
  geom_smooth(method='glm', se=TRUE, na.rm=TRUE) +
  geom_point(color='#023020') + 
  facet_wrap(~variable, scales = 'free',  ncol = 4) + 
  theme_bw()
```

### 1.5 Correlation Matrix

Commentary

```{r corr, cache=TRUE}
rcore <- rcorr(as.matrix(train_df %>% dplyr::select(where(is.numeric))))
coeff <- rcore$r
corrplot(coeff, tl.cex = .5, tl.col="black", method = 'color', addCoef.col = "black",
         type="upper", order="hclust",
         diag=FALSE)
```

## 2. Data preparation

### 2.1 Data types

In order to work with our training dataset, we'll need to first convert some variables to more useful data types:

-   Convert currency columns from character to integer: `INCOME`,`HOME_VAL`,`BLUEBOOK` and `OLDCLAIM`.
-   Convert character columns to factors: `TARGET_FLAG`, `CAR_TYPE`, `CAR_USE`, `EDUCATION`, `JOB`, `MSTATUS`, `PARENT1`, `RED_CAR`, `REVOKED`, `SEX` and `URBANICITY`.

```{r}
# Other changes applied in Section 1.

# Convert these character variables to factors
# factor_vars <- c("TARGET_FLAG","PARENT1","CAR_TYPE","JOB","CAR_USE",
#                  "URBANICITY","RED_CAR","REVOKED","MSTATUS","EDUCATION","SEX")

factor_vars <- c("PARENT1","CAR_TYPE","JOB","CAR_USE",
                 "URBANICITY","RED_CAR","REVOKED","MSTATUS","EDUCATION","SEX")



for (v in factor_vars) {
  train_df <- train_df %>% mutate(!!v := factor(get(v)))
}

## check factor levels
# for (i in factor_vars) {
#   print(lapply(train_df[i], levels))
# }
```

### 2.3 Transformations and Missing Values

Before we go further, we need to identify and handle any missing, NA or negative data values so we can perform log transformations and regression.

First, we'll apply transformations to clean up and align formatting of our variables:

-   Drop the `INDEX` variable.
-   Remove "z\_" from all character class values.
-   Update RED_CAR, replace [no,yes] values with [No, Yes] values.
-   Replace `JOB` blank values with 'Unknown'.

Next, we'll manually adjust two special cases of missing or outlier values.

-   In cases where `YOJ` is zero and `INCOME` is NA, we'll set `INCOME` to zero to avoid imputing new values over legitimate instances of non-employment.
-   There is also at least one value of `CAR_AGE` that is less than zero - we'll assume this is a data collection error and set it to zero (representing a brand-new car.)

```{r}
## Check JOB values where YOJ==0 and INCOME is NA
# train_df %>% filter(YOJ == 0 & is.na(INCOME)) %>% dplyr::select(JOB) %>% unique()

# Manual correction of missing/outlier values
train_df <- train_df %>%
  mutate(CAR_AGE = ifelse(CAR_AGE < 0, 0, CAR_AGE)) %>% 
  mutate(INCOME = ifelse(YOJ == 0 & is.na(INCOME), 0, INCOME))
```

We'll use MICE to impute our remaining variables with missing values - `AGE`, `YOJ`, `CAR_AGE`, `INCOME` and `HOME_VALUE`:

-   We might reasonably assume that relationships exist between these variables (older, more years on the job may correlate with higher income and home value). Taking simple means or medians might suppress those features, but MICE should provide a better imputation.

```{r impute, cache=TRUE}
# MICE imputation of missing values
imputed_Data <- mice(train_df, m=5, maxit = 20, method = 'pmm', seed = 500, printFlag=FALSE)
train_df <- complete(imputed_Data)
```

Next we'll want to consider any power transformations for variables that have skewed distributions.
For example, our numeric response variable `TARGET_AMT` is a good candidate for transformation as its distribution is very highly skewed, and the assumption of normality is required in order to apply linear regression.

-   Log transformation will be applied to variables `INCOME`, `TARGET_AMT`, `OLDCLAIM` to transform their distributions from right-skewed to normally distributed.
-   Similarly, BoxCox transformation will be applied to variables `BLUEBOOK`, `TRAVTIME`, `TIF`, so they also are more normally distributed.

```{r boxcox, fig.keep="none", cache=TRUE}
## Use basic log transformation on `TARGET_AMT`, `OLDCLAIM`, `INCOME`
train_df$TARGET_AMT <- log(train_df$TARGET_AMT + 0.01)
train_df$OLDCLAIM <- log(train_df$OLDCLAIM + 0.01)
#transformed_df$INCOME <-  log(transformed_df$transformed_df$INCOME + 0.01)

# use Box-Cox on `BLUEBOOK`, `TRAVTIME`,  `TIF`
bluebook_boxcox <- boxcox(lm(train_df$BLUEBOOK ~ 1))
bluebook_lambda <- bluebook_boxcox$x[which.max(bluebook_boxcox$y)]
bluebook_trans <- BoxCox(train_df$BLUEBOOK, bluebook_lambda)
train_df$BLUEBOOK <- bluebook_trans

travtime_boxcox <- boxcox(lm(train_df$TRAVTIME ~ 1))
travtime_lambda <- travtime_boxcox$x[which.max(travtime_boxcox$y)]
travtime_trans <- BoxCox(train_df$TRAVTIME, travtime_lambda)
train_df$TRAVTIME <- travtime_trans

tif_boxcox <- boxcox(lm(train_df$TIF ~ 1))
tif_lambda <- tif_boxcox$x[which.max(tif_boxcox$y)]
tif_trans <- BoxCox(train_df$TIF, tif_lambda)
train_df$TIF <- tif_trans
```

To give our models more variables to work with, we'll engineer some additional features:

-   Create bin values for `CAR_AGE`, `HOME_VAL` and `TIF`.
-   Create dummy variables for two-level factors, `MALE`, `MARRIED`, `LIC_REVOKED`, `CAR_RED`, `PRIVATE_USE`, `SINGLE_PARENT` and `URBAN`.

```{r}
## put into bins:  TIF; CAR_AGE; HOMEKIDS; HOME_VAL
q <- quantile(train_df$CAR_AGE)
q <- c(-1,  1,  8, 12, 28)
train_df <- train_df %>% mutate(CAR_AGE_BIN = cut(CAR_AGE, breaks=q, labels=FALSE))

q <- quantile(train_df$HOME_VAL)
q[1] <- -1
train_df <- train_df%>% mutate(HOME_VAL_BIN = cut(HOME_VAL, breaks=q, labels=FALSE))

q <- quantile(train_df$TIF); 
q[1] <- -1
train_df <- train_df %>% mutate(TIF_BIN = cut(TIF, breaks=q, labels=FALSE))
```

```{r dummy_vars}
## Create Dummy Variables for factors with two levels
dummy_vars <- function(df){
  df %>%
    mutate(
      MALE = factor(ifelse(SEX=="M", 1, 0)), 
      MARRIED = factor(ifelse(MSTATUS=="Yes", 1, 0)),
      LIC_REVOKED = factor(ifelse(REVOKED =="Yes", 1, 0)),
      CAR_RED = factor(ifelse(RED_CAR =="Yes", 1, 0)),
      PRIVATE_USE = factor(ifelse(CAR_USE =="Private", 1, 0)),
      SINGLE_PARENT = factor(ifelse(PARENT1 =="Yes", 1, 0)),
      URBAN = factor(ifelse(URBANICITY =="Highly Urban/ Urban", 1, 0))
    ) %>% 
    dplyr::select(-c(SEX, MSTATUS, REVOKED, RED_CAR, CAR_USE, PARENT1, URBANICITY))
      }

train_df <- dummy_vars(train_df)
```

We can examine our final, transformed training dataset and distributions below (with a temporary numeric variable `CAR_CRASH` to represent the response variable for visualization purposes.)

```{r}
skim_without_charts(train_df)
```

```{r}
## Create temporary CAR_CRASH variable from the target_flag for visualization
vis_df <- train_df %>% mutate(CAR_CRASH = ifelse(TARGET_FLAG == 1, 'Yes', 'No'))

a <- vis_df %>% 
  select_if(is.numeric) %>% 
  dplyr::select(!(c(TARGET_AMT))) %>%
  data.table::melt()

a %>% ggplot(aes(x=value)) + 
  geom_density(alpha=1, fill='#47A0F5') + 
  facet_wrap(~variable, scales='free')
```

### 2.4 Visualizations

We can use Mosaic Plots to illustrate the relationship of binary factor variables to `TARGET_FLAG`:

-   Observation
-   Observation

```{r}
## Mosaic plots to view any relationship to the TARGET_FLAG variable for binary factor variables
## PARENT1
plot_parent1 <- ggplot(data = vis_df) +
  geom_mosaic(aes(x = SINGLE_PARENT, fill=CAR_CRASH), offset = 0.005) +
  labs(y="", x="", title="Single Parent", margin=margin(b=10,unit="pt")) +
    theme(panel.background = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks.y= element_blank(),
          axis.ticks.x= element_blank(),
          axis.text.x = element_text(angle = 0, margin = margin(t = -6, unit="mm")),
          plot.title = element_text(hjust = 0.5),
          axis.title.x = element_blank(),
          legend.position = "right")

## Sex
plot_sex <- ggplot(data = vis_df) +
  geom_mosaic(aes(x = MALE, fill=CAR_CRASH), offset = 0.005) +
  labs(y="", x="", title="Sex", margin=margin(b=10,unit="pt")) +
    theme(panel.background = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks.y= element_blank(),
          axis.ticks.x= element_blank(),
          axis.text.x = element_text(angle = 0, margin = margin(t = -6, unit="mm")),
          plot.title = element_text(hjust = 0.5),
          axis.title.x = element_blank(),
          legend.position = "right")

## Marriage status
plot_mstatus <- ggplot(data = vis_df) +
  geom_mosaic(aes(x = MARRIED, fill=CAR_CRASH), offset = 0.005) +
  labs(y="", x="", title="Marriage Status", margin=margin(b=10,unit="pt")) +
    theme(panel.background = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks.y= element_blank(),
          axis.ticks.x= element_blank(),
          axis.text.x = element_text(angle = 0, margin = margin(t = -6, unit="mm")),
          plot.title = element_text(hjust = 0.5),
          axis.title.x = element_blank(),
          legend.position = "right")

## Car use
plot_car_use <- ggplot(data = vis_df) +
  geom_mosaic(aes(x = PRIVATE_USE, fill=CAR_CRASH), offset = 0.005) +
  labs(y="", x="", title="Car Use", margin=margin(b=10,unit="pt")) +
    theme(panel.background = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks.y= element_blank(),
          axis.ticks.x= element_blank(),
          axis.text.x = element_text(angle = 0, margin = margin(t = -6, unit="mm")),
          plot.title = element_text(hjust = 0.5),
          axis.title.x = element_blank(),
          legend.position = "right")

## Red car
plot_red_car <- ggplot(data = vis_df) +
  geom_mosaic(aes(x = CAR_RED, fill=CAR_CRASH), offset = 0.005) +
  labs(y="", x="", title="Red Car?", margin=margin(b=10,unit="pt")) +
    theme(panel.background = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks.y= element_blank(),
          axis.ticks.x= element_blank(),
          axis.text.x = element_text(angle = 0, margin = margin(t = -6, unit="mm")),
          plot.title = element_text(hjust = 0.5),
          axis.title.x = element_blank(),
          legend.position = "right")

## license revoked
plot_revoked <- ggplot(data = vis_df) +
  geom_mosaic(aes(x = LIC_REVOKED, fill=CAR_CRASH), offset = 0.005) +
  labs(y="", x="", title="License Revoked (Past 7 Years)", margin=margin(b=10,unit="pt")) +
    theme(panel.background = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks.y= element_blank(),
          axis.ticks.x= element_blank(),
          axis.text.x = element_text(angle = 0, margin = margin(t = -6, unit="mm")),
          plot.title = element_text(hjust = 0.5),
          axis.title.x = element_blank(),
          legend.position = "right")

## urban or rural area
plot_urbanicity <- ggplot(data = vis_df) +
  geom_mosaic(aes(x = URBAN, fill=CAR_CRASH), offset = 0.005) +
  labs(y="", x="", title="Home / Work Area", margin=margin(b=10,unit="pt")) +
    theme(panel.background = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks.y= element_blank(),
          axis.ticks.x= element_blank(),
          axis.text.x = element_text(angle = 0, margin = margin(t = -6, unit="mm")),
          plot.title = element_text(hjust = 0.5),
          axis.title.x = element_blank(),
          legend.position = "right")

plot_parent1 + plot_sex + plot_mstatus + plot_car_use + plot_red_car + plot_revoked + plot_urbanicity + plot_layout(nrow = 4)

```

We can also use Mosaic Plots to illustrate the relationship of multi-level factor variables to `TARGET_FLAG`:

-   Observation
-   Observation

```{r}
## Mosaic plots to view any relationship to the TARGET_FLAG variable for multi-level factors 
plot_education <- ggplot(data = vis_df) +
  geom_mosaic(aes(x = EDUCATION, fill=CAR_CRASH), offset = 0.005) +
  labs(y="", x="", title="Education", margin=margin(b=10,unit="pt")) +
    theme(panel.background = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks.y= element_blank(),
          axis.ticks.x= element_blank(),
          axis.text.x = element_text(angle = 90, margin = margin(t = -0.5, unit="pt")),
          plot.title = element_text(hjust = 0.5),
          axis.title.x = element_blank(),
          legend.position = "right")

plot_job <- ggplot(data = vis_df) +
  geom_mosaic(aes(x = JOB, fill=CAR_CRASH), offset = 0.005) +
  labs(y="", x="", title="Job Category", margin=margin(b=10,unit="pt")) +
    theme(panel.background = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks.y= element_blank(),
          axis.ticks.x= element_blank(),
          axis.text.x = element_text(angle = 90, margin = margin(t = -0.5, unit="pt")),
          plot.title = element_text(hjust = 0.5),
          axis.title.x = element_blank(),
          legend.position = "right")

plot_car_type <- ggplot(data = vis_df) +
  geom_mosaic(aes(x = CAR_TYPE, fill=CAR_CRASH), offset = 0.005) +
  labs(y="", x="", title="Car Type", margin=margin(b=10,unit="pt")) +
    theme(panel.background = element_blank(),
          axis.text.y = element_blank(),
          axis.ticks.y= element_blank(),
          axis.ticks.x= element_blank(),
          axis.text.x = element_text(angle = 90, margin = margin(t = -0.5, unit="pt")),
          plot.title = element_text(hjust = 0.5),
          axis.title.x = element_blank(),
          legend.position = "right")

plot_education + plot_job + plot_car_type + plot_layout(nrow = 2)
```

### 2.5 Training and Validation Sets

To proceed with modeling, we'll split our training data into train (80%) and validation (20%) datasets.

```{r}
# set.seed(1233)
sample <- sample.split(train_df$TARGET_FLAG, SplitRatio = 0.8)
train_data  <- subset(train_df, sample == TRUE)
valid_data   <- subset(train_df, sample == FALSE)
```

## 3. Multiple Linear Regression

We'll use Multiple Linear Regression to model the `TARGET_AMT` response variable, the estimated cost of a crash for a given observation.

### 3.1 Model 1 - Lasso Regression

The `cv.glmnet()` function was used to perform k-fold cross-validation with variable selection using lasso regularization.
The following attribute settings were selected for the model:

-   type.measure = "mse" - The type.measure is set to minimize the Mean Squared Error for the model.
-   nfold = 10 - Given the size of the dataset we defaulted to 10-fold cross-validation.
-   family = gaussian - For Linear Regression
-   alpha = 1 - The alpha value of 1 sets the variable shrinkage method to lasso.
-   weights = a weight of 0.2638 / n for observation with a 0 `TARGET_AMT` and 0.7362 / n for all observations with all other values of `TARGET_AMT.`
-   standardize = TRUE - Finally, we explicitly set the standardization attribute to TRUE; this will normalize the prediction variables around a mean of zero and a standard deviation of one before modeling.

The resulting model is explored by extracting coefficients at two different values for lambda, lambda.min and lambda.1se respectively.

The coefficients extracted using lambda.min minimizes the mean cross-validated error.
The resulting model includes 33 non-zero coefficients and has an AIC of 60.08.
The coefficients extracted using lambda.1se produce the most regularized model (cross-validated error is within one standard error of the minimum).
For this model there are 25 non-zero coefficients and it has an AIC of 44.23

The coefficients extracted using lambda.1se results in the lowest AIC (highest model performance) with fewer predictor variables.

```{r}
# filter the target data
t_df <- train_data %>% dplyr::select(-c(TARGET_FLAG))

# build X matrix and Y vector
X <- model.matrix(TARGET_AMT ~ ., data=t_df)[,-1]
Y <- t_df[,"TARGET_AMT"] 

# calculate the weights for the target flag
w <- table(train_data$TARGET_FLAG)
n <- length(Y)
prop_0 <- w[1] / (w[1] + w[2])
prop_1 <- w[2] / (w[1] + w[2])

# calculate the weights vector
weights_lm  <- ifelse(train_data$TARGET_FLAG == 0,  prop_1/n, prop_0/n)
```

```{r}
lasso.lm.model <- cv.glmnet(
  x=X,y=Y, # Y already logged in prep
  family = "gaussian",
  type.measure="mse",
  standardize = TRUE, # standardize
  nfold = 10,
  weights = weights_lm,
  alpha=1) # alpha=1 is lasso

lasso.lm.model

l.min <- lasso.lm.model$lambda.min
l.1se <- lasso.lm.model$lambda.1se
```

```{r}
par(mfrow=c(2,2))

plot(lasso.lm.model)
plot(lasso.lm.model$glmnet.fit, xvar="lambda", label=TRUE)
plot(lasso.lm.model$glmnet.fit, xvar='dev', label=TRUE)
```

```{r}
assess.glmnet(lasso.lm.model,           
              newx = X,              
              newy = Y,
              s = 'lambda.min',
              family = 'gaussian')    

print(glmnet_cv_aicc(lasso.lm.model, 'lambda.min'))
print(glmnet_cv_aicc(lasso.lm.model, 'lambda.1se'))
```

A closer look at the remaining 37 non-zero coefficients for the selected lambda value of lambda.min (`r round(lasso.lm.model$lambda.min,3)`) we can observe the top predictor variables `URBANICITY Highly Urban/ Urban` predictor variable has the largest impact on the response variable `TARGET_AMT`.

In the lasso model the coefficient for `URBANICITY Highly Urban/ Urban` home work area is biggest contributor to the cost estimates of a car crash by a factor of 2.

Reviewing the top 5 predictor variables that impact likelihood and cost associated with an accident:

-   `URBANICITY Highly Urban/ Urban` - working or living in an urban neighborhood increase expected cost associated with a crash
-   `JOB Doctor` - being a doctor reduces the expected costs associated with a crash
-   `JOB Manager` - being a manager reduces the expected costs associated with a crash
-   `CAR_TYPE Sports Car` - owning a sports car increases the expected costs associated with a crash
-   `CAR_USE Private` - using a car for private activities reduces the expected costs associated with a crash
-   `REVOKED Yes` - a history of having a revoked license increases the expected costs associated with a crash

Some of the notable coefficients that drop out of the model include:

-   `HOME_VAL`
-   `JOB Professional`
-   `CAR_AGE`
-   `CAR_RED`

```{r}
coef(lasso.lm.model, s = "lambda.min")
```

```{r}
# # test
# tbl <- data.matrix(coef(lasso.lm.model, s = "lambda.min"))
# 
# tbl <- data.matrix(tbl[order(tbl, decreasing=TRUE),])
# 
# kable(
#   list(tbl[1:20,], tbl[21:41,]),
#   booktabs = TRUE
# ) %>% kable_styling()

```

```{r fig.show="hold", out.width="50%", fig.height=6}
vip(lasso.lm.model, num_features=20 ,geom = "col", include_type=TRUE, lambda = "lambda.min")

coeffs.table <- coeff2dt(fitobject = lasso.lm.model, s = "lambda.1se")

coeffs.table %>% mutate(name = fct_reorder(name, desc(coefficient))) %>%
ggplot() +
  geom_col(aes(y = name, x = coefficient, fill = {coefficient > 0})) +
  xlab(label = "") +
  ggtitle(expression(paste("Lasso Coefficients with ", lambda, " = 0.0275"))) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.5),legend.position = "none")
```

As mentioned earlier, the dataset has a high correlation between predictor variables.
The lasso regression approaches this issue by selecting the variable with the highest correlation and shrinking the remaining variables (as can be seen in the plot of coefficients).

#### Model Performance

The lasso model using coefficients extracted at lambda.1se was used to predict the 60,421 test cases and comparing the predicted insurance AMT to the actual cost of a car crash.
The predicted cost of the crash include negative numbers that are effectively 0.
We selected a threshold cost and assigning 0 to all amounts below that threshold value.
Since

In the training data 337.50 was the lowest crash cost included in the dataset.
We used 100 as the measurement threshold and assume that all predicted costs below 100 dollars are effectively 0.

```{r}
t0_df <- valid_data %>% dplyr::select(-c(TARGET_FLAG)) 
X_test <- model.matrix(TARGET_AMT ~ ., data=t0_df)[,-1]
Y_test <- t0_df[,"TARGET_AMT"] 

lassoPred <- predict(
  lasso.lm.model, 
  newx = X_test,
  type = "response",
  s = 'lambda.1se')

lassoPred <- exp(lassoPred) - 0.001

pred_ln_df <- valid_data %>% drop_na()
pred_ln_df$TARGET_AMT_PRED_RAW <- lassoPred[,1]
pred_ln_df$TARGET_AMT_PRED <- ifelse(lassoPred > 100, lassoPred, 0)[,1]
```

Using the yardstick package to measure model performance, mape, smape and mpe return NaNs while the `mase` = 0.578 and `rmse` = 4984.

```{r}
multi_metric <- metric_set(mape, smape, mase, mpe, rmse)
pred_ln_df %>% multi_metric(truth=TARGET_AMT, estimate=TARGET_AMT_PRED)
```

Analyzing a scatter plot of the prediction errors vs measured costs and a comparative histogram of the predicted and measured costs highlights a shortcoming of the lasso model.
The model consistently predicts crash costs lower than the actual measured crash costs.
The gap is more pronounced when looking at predicted and ??????

```{r fig.show="hold", out.width="50%", fig.height=6}
n <- nrow(t0_df)
x <- t0_df$TARGET_AMT
e <- lassoPred - t0_df$TARGET_AMT

plot(x, e,  
     xlab = "cost", 
     ylab = "residuals", 
     bg = "steelblue", 
     col = "darkgray", cex = 1.5, pch = 21, frame = FALSE)
abline(h = 0, lwd = 2)
for (i in 1 : n) 
  lines(c(x[i], x[i]), c(e[i], 0), col = "red" , lwd = 1)

# comparative histogram
t0_df <- pred_ln_df %>% dplyr::select(TARGET_AMT,TARGET_AMT_PRED) %>% pivot_longer(c(TARGET_AMT,TARGET_AMT_PRED),
                                 names_to='variable' , values_to = 'value')

t0_df %>% dplyr::filter(value <= 1000) %>% 
  ggplot(aes(x=value, fill=variable)) +geom_histogram(bins=5) 

t0_df %>% dplyr::filter(value > 1000) %>% 
  ggplot(aes(x=value, fill=variable)) +geom_histogram(bins=100) 
```

#### Model Assumptions

To reduce multicollinearity we can use regularization that means to keep all the features but reducing the magnitude of the coefficients of the model.
This is a good solution when each predictor contributes to predict the dependent variable.

The Standardized Residuals plot shows increasing variance at higher values of the response variable.

```{r}
pred_ln_df$PER_ERR <- (pred_ln_df$TARGET_AMT_PRED - pred_ln_df$TARGET_AMT)
```

The lasso regression solves the multicollinearity issue by selecting the variable with the largest coefficient while setting the rest to (nearly) zero.

```{r}
pred_ln_df %>% ggplot(aes(x=TARGET_AMT, colour=TARGET_AMT_PRED, y=PER_ERR)) +
  geom_point()
```

### 3.2 Model 2 - Stepwise Feature Selection

```{r}
# load data
t_df <- train_data %>% dplyr::select(-c(TARGET_FLAG))
v_df <- valid_data %>% dplyr::select(-c(TARGET_FLAG))

# build model
stepwise.base.lm.model <- lm(TARGET_AMT ~ ., data = t_df)

# select features and refit by stepwise selection (AIC)
stepwise.lm.model <- stepAIC(stepwise.base.lm.model, trace=FALSE, direction='backward')
```

#### Model Performance

```{r}
# summary table
cap <- paste('Adjusted R2:',round(summary(stepwise.lm.model)$adj.r.squared,5))

stepwise.lm.model %>% tidy() %>% 
  dplyr::select(term, estimate, `p.value`) %>%
  arrange(p.value, desc(abs(estimate))) %>% 
  # mutate(est_orig = get_boxcox_exp(estimate, lm_bc_lambda)) %>%
  # relocate(est_orig, .after=estimate) %>%
  kable(digits = 3, caption=cap)
```

```{r}
# validate and calculate RMSE
stepwise.lm.valid <- predict(stepwise.lm.model, newdata = v_df)
stepwise.lm.eval <- bind_cols(target = v_df$TARGET_AMT, predicted=stepwise.lm.valid)
stepwise.lm.rmse <- sqrt(mean((stepwise.lm.eval$target - stepwise.lm.eval$predicted)^2)) 

# plot targets vs predicted
stepwise.lm.eval %>%
  ggplot(aes(x = target, y = predicted)) +
  geom_point(alpha = .3) +
  geom_smooth(method="lm", color='grey', alpha=.3, se=FALSE) +
  labs(title=paste('RMSE:',round(stepwise.lm.rmse,1)))
```

The resulting model is much more parsimonious than the first, with statistically significant results for three predictors, **bluebook**, **mvr_pts** and **mstatus_yes**.

The Adjusted R-Squared is better than Model 1 but still very low (0.0167) meaning this model only explains about 1.7% of the total variance in the response variable **target_amt**. However, an examination of the residuals indicates most of the key assumptions for linear regression are met - the Residuals vs Fitted plot shows a more constant variability of the residuals, and the Q-Q plot indicates a greater level of normality.

The summary table includes the estimate transformed to original scale for easier interpretation.In this case, the 'base' *target_amt* would be estimated at \$3,434.76 with an increase in 1% per each dollar of bluebook value, a 1.07% increase if the driver were male, and 0.9% decrease if the driver were married.

#### Model Assumptions

```{r}
# residual plots
plot(stepwise.lm.model)
```

### 3.3 Model 3 -

#### Model Performance

### 3.4 Model selection

## 4. Binary Logistic Regression

We'll use Binary Logistic Regression to classify our response variable `TARGET_FLAG`, the probability of a car crash for a given observation.

### 4.1 Model 1 - Lasso

Lasso Regression may be a good candidate for this dataset, since we are dealing with a large number of complex variables.
Lasso helps identify the most important variables and reduces the model complexity.

The cv.glmnet() function was also used as logistic regression model.
Similar to the regression model k-fold cross-validation was performed with variable selection using lasso regularization.
The following attribute settings were selected for the model:

-   type.measure = "class" - The type.measure is set to class to minimize the mis-classification errors of the model since the accurate classification of the validation data set is the desired outcome.
-   nfold = 10 - Given the size of the training dataset, we opted for 10-fold cross-validation as a default.
-   family = binomial - For Logistic Regression, the family attribute of the function is set to binomial.
-   link = logit - For this model, we choose the default link function for a logistic model.
-   alpha =1 - The alpha value of 1 sets the variable shrinkage method to lasso.
-   weights = a weight of 0.2638 / n for observation with a 0 `TARGET_FLAG` and 0.7362 / n observations with a 1 value of `TARGET_FLAG`.
-   standardize = TRUE - Finally, we explicitly set the standardization attribute to TRUE; this will normalize the prediction variables around a mean of zero and a standard deviation of one before modeling.

The resulting model is explored by extracting coefficients at two different values for lambda, lambda.min and lambda.1se respectively.

-   The coefficients extracted using lambda.min minimizes the mean cross-validated error. The resulting model includes 35 non zero coefficients and has an AIC of -1605.418.
-   The coefficients extracted using lambda.1se produce the most regularized model (cross-validated error is within one standard error of the minimum). The resulting model includes 25 no zero coefficients and has an AIC of -1503.695,

The coefficients extracted using lambda.min results in the lowest AIC and highest performance model.

```{r}
t_df <- train_data %>% dplyr::select(-c(TARGET_AMT)) %>% drop_na()

# build X matrix and Y vector
X <- model.matrix(TARGET_FLAG ~ ., data=t_df)[,-1]
Y <- t_df[,"TARGET_FLAG"] 

# calculate weights
w <- table(train_data$TARGET_FLAG)
n <- length(Y)
prop_0 <- w[1] / (w[1] + w[2])
prop_1 <- w[2] / (w[1] + w[2])
  
# calculate weight vector 
weights_log  <- ifelse(train_data$TARGET_FLAG == 0,  prop_1 / n, prop_0 / n)
```

```{r}
lasso.log.model<- cv.glmnet(
  x=X,y=Y,
  family = "binomial",
  link = "logit",
  standardize = TRUE,
  nfold = 5,
  alpha=1) # alpha=1 is lasso

lasso.log.model

l.min <- lasso.log.model$lambda.min
l.1se <- lasso.log.model$lambda.1se
```

```{r}
par(mfrow=c(2,2))

plot(lasso.log.model)
plot(lasso.log.model$glmnet.fit, xvar="lambda", label=TRUE)
plot(lasso.log.model$glmnet.fit, xvar='dev', label=TRUE)

rocs <- roc.glmnet(lasso.log.model, newx = X, newy = Y )
plot(rocs,type="l")  
```

```{r}
assess.glmnet(lasso.log.model,           
                newx = X,              
                newy = Y,
                family = "binomial",
                s = 'lambda.min'
              )    

print(glmnet_cv_aicc(lasso.log.model, 'lambda.min'))
print(glmnet_cv_aicc(lasso.log.model, 'lambda.1se'))
```

A closer look at the remaining 36 non-zero coefficients for the selected lambda value of lambda.min we can observe the `URBANICITY Highly Urban/ Urban` predictor variable has the largest impact on the prediction of a car crash by a factor of three.
Reviewing the top 5 predictor variables that impact likelihood and cost associated with an accident:

-   `URBANICITY Highly Urban/ Urban` - working or living in an urban neighborhood increase expected cost associated with a crash
-   `CAR_USE Private` - using a car for private activities reduces
-   `JOB Manager` - being a manager reduces the expected costs associated with a crash
-   `REVOKED Yes` - a history of having a revoked license increases the expected costs associated with a crash
-   `JOB Doctor` - being a doctor reduces the expected costs associated with a crash

The JOBStudent coefficient is the only predictor variable that drops out, however several variable including INCOME, HOME_VAL and OLDCLAIM are srunk substantially.

```{r}
coef(lasso.log.model, s = "lambda.min" )
```

```{r fig.show="hold", out.width="50%", fig.height=6}
vip(lasso.log.model, num_features=20 ,geom = "col", include_type=TRUE, lambda = "lambda.min")

coeffs.table <- coeff2dt(fitobject = lasso.log.model, s = "lambda.min")

coeffs.table %>% mutate(name = fct_reorder(name, desc(coefficient))) %>%
ggplot() +
  geom_col(aes(y = name, x = coefficient, fill = {coefficient > 0})) +
  xlab(label = "") +
  ggtitle(expression(paste("Lasso Coefficients with ", lambda, " = 0.0275"))) +
  theme_bw() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust=0.5),legend.position = "none")
```

#### Model Performance

The coefficients extracted at the lambda.min value are used to predict the likelihood of an accident.
The confusion matrix highlights an accuracy of 73.7%.

```{r}
# drop TARGET_AMT
t0_df <- valid_data %>% dplyr::select(-c(TARGET_AMT))

# build X matrix and Y vector
X_test <- model.matrix(TARGET_FLAG ~ ., data=t0_df)[,-1]
Y_test <- t0_df[,"TARGET_FLAG"] 

# predict using coefficients at lambda.min
lassoPred <- predict(lasso.log.model, newx = X_test, type = "response", s = 'lambda.min')

pred_log_df <- valid_data %>% drop_na()
pred_log_df$TARGET_FLAG_PROB <- lassoPred[,1]
pred_log_df$TARGET_FLAG_PRED <- ifelse(lassoPred > 0.5, 1, 0)[,1]
```

```{r}
confusion.glmnet(lasso.log.model, newx = X_test, newy = Y_test, s = 'lambda.min')
```

#### Checking Model Assumptions

Again we check linear relationship between independent variables and the Logit of the target variable.
Visually inspecting the results there is a linear trend in the relationship but there are deviations from the straight line in all variables.
The lasso regression solves the multicollinearity issue by selecting the variable with the largest coefficient while setting the rest to (nearly) zero.

```{r}
pred_log_df <- pred_log_df %>%
  mutate(logit = log(TARGET_FLAG_PROB/(1-TARGET_FLAG_PROB))) 

m_df <- pred_log_df %>% dplyr::select(where(is.numeric)) %>% pivot_longer(!c(TARGET_AMT,TARGET_FLAG_PROB,TARGET_FLAG_PRED,logit), 
                                 names_to='variable' , values_to = 'value')

# Scatter plot
ggplot(m_df, aes(logit, value))+
  geom_point(size = 0.5, alpha = 0.5) +
  geom_smooth(method = "loess") + 
  theme_bw() + 
  facet_wrap(~variable, scales = "free_y")

# Scatter plot 2
pred_log_df$index <- as.numeric(rownames(pred_log_df))
pred_log_df$resid <- pred_log_df$TARGET_FLAG_PROB - pred_log_df$TARGET_FLAG    

ggplot(pred_log_df, aes(index, resid)) + 
  geom_point(aes(color = TARGET_FLAG), alpha = .5) +
  theme_bw()
```

### 4.2 Model 2 - Stepwise Feature Selection

### 4.3 Model 3 -

### 4.4 Model selection

```{r}


results_lm_tbl <- tibble(
                      Model = character(),
                      mape = numeric(), 
                      smape = numeric(), 
                      mase = numeric(), 
                      mpe = numeric(), 
                      rmse = numeric(),
                      AIC = numeric()
                )

results_log_tbl <- tibble(
                      Model = character(),
                      Accuracy = numeric(), 
                      "Classification error rate" = numeric(),
                      F1 = numeric(),
                      Deviance= numeric(), 
                      R2 = numeric(),
                      Sensitivity = numeric(),
                      Specificity = numeric(),
                      Precision = numeric(),
                      AIC= numeric()
                )

```

\*\* Model 3.1: Lasso Linear Regression \*\*

```{r}

# build X matrix and Y vector
t0_df <- valid_data %>% dplyr::select(-c(TARGET_FLAG)) %>% drop_na()
X_test <- model.matrix(TARGET_AMT ~ ., data=t0_df)[,-1]
Y_test <- t0_df[,"TARGET_AMT"] 



lasso.r1 <- assess.glmnet(lasso.lm.model,
                                newx = X_test,
                                newy = Y_test )
lasso.r2 <- glmnet_cv_aicc(lasso.lm.model, 'lambda.min')


multi_metric <- metric_set(mape, smape, mase, mpe, rmse)
m_df <- pred_ln_df %>% multi_metric(truth=TARGET_AMT, estimate=TARGET_AMT_PRED)



results_lm_tbl <- results_lm_tbl %>% add_row(tibble_row(
                      Model = "M4.1:Lasso Linear",
                      mape = m_df[[1,3]],
                      smape = m_df[[2,3]],
                      mase = m_df[[3,3]],
                      mpe = m_df[[4,3]],
                      rmse = m_df[[5,3]],
                      AIC = lasso.r2$AICc)
                     )


```

\*\* Model 4.1: Lasso Logistic Regression \*\*

```{r}

conf_matrix_1 = confusionMatrix(factor(pred_log_df$TARGET_FLAG_PRED),factor(pred_log_df$TARGET_FLAG), "1")
conf_matrix_1$byClass["F1"]



# build X matrix and Y vector
t0_df <- valid_data %>% dplyr::select(-c(TARGET_AMT)) %>% drop_na()
X_test <- model.matrix(TARGET_FLAG ~ ., data=t0_df)[,-1]
Y_test <- t0_df[,"TARGET_FLAG"] 


lasso.r1 <- assess.glmnet(lasso.log.model,           
                                newx = X_test,              
                                newy = Y_test,
                                family = "binomial",
                                s = 'lambda.min'
                          )   
lasso.r2 <- glmnet_cv_aicc(lasso.log.model, 'lambda.min')



results_log_tbl <- results_log_tbl %>% add_row(tibble_row(
                      Model = "M4.1:Lasso Logistic", 
                      Accuracy=lasso.r1$auc[1], 
                      "Classification error rate" = 1 - lasso.r1$auc[1],
                      F1 = conf_matrix_1$byClass["F1"],
                      Deviance=lasso.r1$deviance[[1]], 
                      R2 = NA,
                      Sensitivity = conf_matrix_1$byClass["Sensitivity"],
                      Specificity = conf_matrix_1$byClass["Specificity"],
                      Precision = conf_matrix_1$byClass["Precision"],
                      AIC= lasso.r2$AICc)
                     )



```

Regression

```{r}

#t1 <- as_tibble(cbind(variables = names(results_tbl), t(results_tbl)))

kable(results_lm_tbl, digits=4) %>% 
  kable_styling(bootstrap_options = "basic", position = "center")

```

Logistic

```{r}


#t1 <- as_tibble(cbind(variables = names(results_tbl), t(results_tbl)))

kable(results_log_tbl, digits=4) %>% 
  kable_styling(bootstrap_options = "basic", position = "center")

```

## 5. Predictions

## 6. Conclusion

## 7. References

## Appendix: R code
